name: üîí Enhanced Security Scanner

on:
  workflow_dispatch:
    inputs:
      target_repo:
        description: 'Repository URL to scan'
        required: true
        type: string
      scan_id:
        description: 'Unique scan identifier'
        required: true
        type: string
      callback_url:
        description: 'Callback URL for results'
        required: true
        type: string
      scan_depth:
        description: 'Scan depth level'
        required: false
        default: 'standard'
        type: choice
        options:
          - quick
          - standard
          - comprehensive

env:
  SCAN_ID: ${{ github.event.inputs.scan_id }}
  CALLBACK_URL: ${{ github.event.inputs.callback_url }}
  TARGET_REPO: ${{ github.event.inputs.target_repo }}
  SCAN_DEPTH: ${{ github.event.inputs.scan_depth }}
  # Optimized tool versions
  TRIVY_VERSION: "0.50.1"
  SEMGREP_VERSION: "1.45.0"
  NODE_VERSION: "20"
  PYTHON_VERSION: "3.11"

jobs:
  security-scan:
    name: üîç Enhanced Security Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: üìã Initialize Scan Environment
        run: |
          echo "üöÄ Enhanced Security Scan Starting"
          echo "üì¶ Repository: ${{ env.TARGET_REPO }}"
          echo "üÜî Scan ID: ${{ env.SCAN_ID }}"
          echo "üîç Depth: ${{ env.SCAN_DEPTH }}"
          echo "‚è∞ Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Set scan timing
          echo "SCAN_START_TIME=$(date +%s)" >> $GITHUB_ENV
          echo "SCAN_TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          
          # Initialize directories
          mkdir -p {scan-results,cache-temp}
          
          # Initialize metrics
          echo "FILES_SCANNED=0" >> $GITHUB_ENV
          echo "DIRECTORIES_SCANNED=0" >> $GITHUB_ENV

      # ========================================
      # ENHANCED CACHING STRATEGY
      # ========================================
      - name: üìÖ Generate Dynamic Cache Keys
        id: cache-keys
        run: |
          DATE_KEY=$(date +'%Y-%m-%d')
          WEEK_KEY=$(date +'%Y-W%U')
          
          echo "date=${DATE_KEY}" >> $GITHUB_OUTPUT
          echo "week=${WEEK_KEY}" >> $GITHUB_OUTPUT
          echo "trivy-key=trivy-v${{ env.TRIVY_VERSION }}-${DATE_KEY}" >> $GITHUB_OUTPUT
          echo "semgrep-key=semgrep-v${{ env.SEMGREP_VERSION }}-${WEEK_KEY}" >> $GITHUB_OUTPUT

      - name: üóÑÔ∏è Multi-Layer Security Tools Cache
        id: cache-security-tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/bin/trivy
            ~/.local/bin/semgrep
            ~/.cache/trivy
            ~/.cache/semgrep
            ~/.cache/pip
            ~/.npm
          key: security-tools-v3-${{ steps.cache-keys.outputs.trivy-key }}-${{ steps.cache-keys.outputs.semgrep-key }}
          restore-keys: |
            security-tools-v3-${{ steps.cache-keys.outputs.trivy-key }}-
            security-tools-v3-trivy-v${{ env.TRIVY_VERSION }}-
            security-tools-v3-

      # ========================================
      # OPTIMIZED TOOL INSTALLATION
      # ========================================
      - name: üîß Install Enhanced Security Tools
        id: install-tools
        run: |
          echo "üîß Installing enhanced security toolkit..."
          
          # Create local bin directory
          mkdir -p ~/.local/bin
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          
          # Parallel installation function
          install_tool() {
            local tool=$1
            local install_cmd=$2
            local verify_cmd=$3
            
            echo "üì¶ Installing $tool..."
            if eval "$verify_cmd" >/dev/null 2>&1; then
              echo "‚úÖ $tool already available"
              return 0
            fi
            
            if eval "$install_cmd"; then
              if eval "$verify_cmd" >/dev/null 2>&1; then
                echo "‚úÖ $tool installed successfully"
                return 0
              fi
            fi
            
            echo "‚ùå $tool installation failed"
            return 1
          }
          
          # Robust Semgrep installation with fallbacks
          install_semgrep() {
            echo "üì¶ Installing Semgrep..."
            
            # Method 1: Direct pip install
            if pip3 install --user "semgrep==${{ env.SEMGREP_VERSION }}" >/dev/null 2>&1; then
              if ~/.local/bin/semgrep --version >/dev/null 2>&1; then
                echo "‚úÖ Semgrep installed via pip --user"
                return 0
              fi
            fi
            
            # Method 2: Try without version constraint
            echo "üîÑ Trying without version constraint..."
            if pip3 install --user semgrep >/dev/null 2>&1; then
              if ~/.local/bin/semgrep --version >/dev/null 2>&1; then
                echo "‚úÖ Semgrep installed (latest version)"
                return 0
              fi
            fi
            
            # Method 3: Global installation fallback
            echo "üîÑ Trying global installation..."
            if pip3 install "semgrep==${{ env.SEMGREP_VERSION }}" >/dev/null 2>&1; then
              # Find semgrep and create symlink
              SEMGREP_PATH=$(which semgrep 2>/dev/null || find /usr/local/bin /opt -name "semgrep" 2>/dev/null | head -1)
              if [ -n "$SEMGREP_PATH" ] && [ -x "$SEMGREP_PATH" ]; then
                ln -sf "$SEMGREP_PATH" ~/.local/bin/semgrep
                if ~/.local/bin/semgrep --version >/dev/null 2>&1; then
                  echo "‚úÖ Semgrep installed globally and linked"
                  return 0
                fi
              fi
            fi
            
            echo "‚ùå All Semgrep installation methods failed"
            return 1
          }
          
          # Install tools with improved logic
          install_tool() {
            local tool=$1
            local install_func=$2
            local verify_cmd=$3
            
            echo "üì¶ Installing $tool..."
            if eval "$verify_cmd" >/dev/null 2>&1; then
              echo "‚úÖ $tool already available"
              return 0
            fi
            
            if eval "$install_func"; then
              return 0
            fi
            
            echo "‚ùå $tool installation failed"
            return 1
          }
          
          # Install Trivy
          install_trivy() {
            wget -qO- "https://github.com/aquasecurity/trivy/releases/download/v${{ env.TRIVY_VERSION }}/trivy_${{ env.TRIVY_VERSION }}_Linux-64bit.tar.gz" | tar -xzf - -C ~/.local/bin trivy && chmod +x ~/.local/bin/trivy
          }
          
          # Install in parallel (background processes)
          install_tool "Trivy" "install_trivy" "~/.local/bin/trivy --version" &
          TRIVY_PID=$!
          
          install_tool "Semgrep" "install_semgrep" "~/.local/bin/semgrep --version" &
          SEMGREP_PID=$!
          
          # Wait for installations
          wait $TRIVY_PID
          TRIVY_OK=$?
          
          wait $SEMGREP_PID
          SEMGREP_OK=$?
          
          # Update Trivy DB in background
          if [ $TRIVY_OK -eq 0 ]; then
            echo "üîÑ Updating Trivy vulnerability database..."
            ~/.local/bin/trivy image --download-db-only >/dev/null 2>&1 &
          fi
          
          # Set outputs
          echo "trivy-ok=$([[ $TRIVY_OK -eq 0 ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "semgrep-ok=$([[ $SEMGREP_OK -eq 0 ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          
          echo "üìä Tool Installation Status:"
          echo "  Trivy: $([[ $TRIVY_OK -eq 0 ]] && echo "‚úÖ" || echo "‚ùå")"
          echo "  Semgrep: $([[ $SEMGREP_OK -eq 0 ]] && echo "‚úÖ" || echo "‚ùå")"

      # ========================================
      # SMART REPOSITORY CLONING
      # ========================================
      - name: üìÇ Smart Repository Clone
        id: clone-repo
        run: |
          echo "üîÑ Intelligent repository cloning..."
          
          # Extract repository information
          REPO_URL="${{ env.TARGET_REPO }}"
          REPO_NAME=$(echo $REPO_URL | sed 's/.*github\.com\///g' | sed 's/\.git$//g')
          REPO_DIR=$(echo $REPO_NAME | sed 's/.*\///g')
          
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "REPO_DIR=$REPO_DIR" >> $GITHUB_ENV
          
          # Dynamic clone strategy based on scan depth
          case "${{ env.SCAN_DEPTH }}" in
            "quick")
              CLONE_DEPTH=1
              CLONE_OPTS="--single-branch --no-tags"
              ;;
            "comprehensive")
              CLONE_DEPTH=100
              CLONE_OPTS="--no-single-branch"
              ;;
            *)
              CLONE_DEPTH=20
              CLONE_OPTS="--single-branch"
              ;;
          esac
          
          echo "üì• Cloning with depth: $CLONE_DEPTH, options: $CLONE_OPTS"
          
          # Clone with optimizations
          git clone \
            --depth=$CLONE_DEPTH \
            $CLONE_OPTS \
            --filter=blob:none \
            "$REPO_URL" "$REPO_DIR"
          
          cd "$REPO_DIR"
          
          # Enhanced file analysis
          FILE_COUNT=$(find . -type f -not -path './.git/*' | wc -l)
          DIR_COUNT=$(find . -type d -not -path './.git/*' | wc -l)
          REPO_SIZE=$(du -sh . | cut -f1)
          
          # Detect project types for targeted scanning
          PROJECT_TYPES=""
          [ -f "package.json" ] && PROJECT_TYPES="$PROJECT_TYPES nodejs"
          [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] && PROJECT_TYPES="$PROJECT_TYPES python"
          [ -f "Dockerfile" ] && PROJECT_TYPES="$PROJECT_TYPES docker"
          [ -f "pom.xml" ] || [ -f "build.gradle" ] && PROJECT_TYPES="$PROJECT_TYPES java"
          [ -f "go.mod" ] && PROJECT_TYPES="$PROJECT_TYPES golang"
          [ -f "Cargo.toml" ] && PROJECT_TYPES="$PROJECT_TYPES rust"
          
          echo "FILES_SCANNED=$FILE_COUNT" >> $GITHUB_ENV
          echo "DIRECTORIES_SCANNED=$DIR_COUNT" >> $GITHUB_ENV
          echo "PROJECT_TYPES=${PROJECT_TYPES:-unknown}" >> $GITHUB_ENV
          
          echo "‚úÖ Repository cloned: $FILE_COUNT files, $DIR_COUNT dirs, $REPO_SIZE"
          echo "üîç Detected project types: ${PROJECT_TYPES:-none}"

      # ========================================
      # PARALLEL SECURITY SCANS
      # ========================================
      - name: üîç Comprehensive Vulnerability Scan
        id: trivy-comprehensive
        if: steps.install-tools.outputs.trivy-ok == 'true'
        run: |
          echo "üîç Running comprehensive Trivy scan..."
          cd "${{ env.REPO_DIR }}"
          
          # Enhanced Trivy scan with multiple scanners
          ~/.local/bin/trivy fs . \
            --format json \
            --output ../scan-results/trivy-vulnerabilities.json \
            --severity CRITICAL,HIGH,MEDIUM,LOW \
            --scanners vuln,config,secret \
            --timeout 15m \
            --parallel 4 \
            --quiet \
            --exit-code 0 || {
              echo "‚ö†Ô∏è Trivy scan completed with warnings"
              echo '{"Results": []}' > ../scan-results/trivy-vulnerabilities.json
            }
          
          echo "‚úÖ Comprehensive vulnerability scan completed"

      - name: üéØ Advanced Static Analysis
        id: semgrep-analysis
        if: steps.install-tools.outputs.semgrep-ok == 'true'
        run: |
          echo "üéØ Running advanced static analysis..."
          cd "${{ env.REPO_DIR }}"
          
          # Intelligent ruleset selection based on project types
          RULESETS="auto"
          case "${{ env.PROJECT_TYPES }}" in
            *nodejs*) RULESETS="$RULESETS javascript typescript" ;;
            *python*) RULESETS="$RULESETS python" ;;
            *java*) RULESETS="$RULESETS java" ;;
            *golang*) RULESETS="$RULESETS go" ;;
          esac
          
          # Run Semgrep with dynamic rulesets
          ~/.local/bin/semgrep \
            --config=$RULESETS \
            --json \
            --output=../scan-results/semgrep-analysis.json \
            --timeout=300 \
            --max-target-bytes=1000000 \
            --quiet \
            . || {
              echo "‚ö†Ô∏è Semgrep analysis completed with findings"
              echo '{"results": []}' > ../scan-results/semgrep-analysis.json
            }
          
          echo "‚úÖ Advanced static analysis completed"

      - name: üîê Enhanced Secret Detection
        id: secret-scan
        if: steps.install-tools.outputs.trivy-ok == 'true'
        run: |
          echo "üîê Enhanced secret detection..."
          cd "${{ env.REPO_DIR }}"
          
          # Multi-layer secret detection
          ~/.local/bin/trivy fs . \
            --scanners secret \
            --format json \
            --output ../scan-results/trivy-secrets.json \
            --severity CRITICAL,HIGH,MEDIUM \
            --timeout 5m \
            --quiet \
            --exit-code 0 || {
              echo "‚ö†Ô∏è Secret scan completed with findings"
              echo '{"Results": []}' > ../scan-results/trivy-secrets.json
            }
          
          echo "‚úÖ Enhanced secret detection completed"

      # ========================================
      # INTELLIGENT RESULT PROCESSING
      # ========================================
      - name: üß† Intelligent Result Analysis
        id: analyze-results
        run: |
          echo "üß† Processing scan results with enhanced intelligence..."
          cd scan-results
          
          # Create enhanced Python analyzer
          cat > enhanced_analyzer.py << 'EOF'
          import json
          import sys
          import os
          from collections import defaultdict
          import hashlib
          
          class EnhancedSecurityAnalyzer:
              def __init__(self):
                  self.vulnerability_counts = defaultdict(int)
                  self.all_vulnerabilities = []
                  self.deduplication_hashes = set()
                  
              def deduplicate_vulnerability(self, vuln_data):
                  """Create hash for deduplication"""
                  dedup_key = f"{vuln_data.get('id', '')}-{vuln_data.get('package', '')}-{vuln_data.get('severity', '')}"
                  vuln_hash = hashlib.md5(dedup_key.encode()).hexdigest()
                  
                  if vuln_hash in self.deduplication_hashes:
                      return False
                  
                  self.deduplication_hashes.add(vuln_hash)
                  return True
          
              def parse_trivy_results(self, filename):
                  """Enhanced Trivy parser with deduplication"""
                  if not os.path.exists(filename):
                      return
                  
                  try:
                      with open(filename, 'r') as f:
                          data = json.load(f)
                      
                      for result in data.get('Results', []):
                          target = result.get('Target', 'Unknown')
                          
                          # Process vulnerabilities
                          for vuln in result.get('Vulnerabilities', []):
                              vuln_data = self.normalize_trivy_vulnerability(vuln, target)
                              
                              if self.deduplicate_vulnerability(vuln_data):
                                  severity = vuln_data['severity'].lower()
                                  self.vulnerability_counts[severity] += 1
                                  self.all_vulnerabilities.append(vuln_data)
                          
                          # Process misconfigurations
                          for misc in result.get('Misconfigurations', []):
                              vuln_data = self.normalize_trivy_misconfiguration(misc, target)
                              
                              if self.deduplicate_vulnerability(vuln_data):
                                  severity = vuln_data['severity'].lower()
                                  self.vulnerability_counts[severity] += 1
                                  self.all_vulnerabilities.append(vuln_data)
                          
                          # Process secrets
                          for secret in result.get('Secrets', []):
                              vuln_data = self.normalize_trivy_secret(secret, target)
                              
                              if self.deduplicate_vulnerability(vuln_data):
                                  severity = vuln_data['severity'].lower()
                                  self.vulnerability_counts[severity] += 1
                                  self.all_vulnerabilities.append(vuln_data)
                  
                  except Exception as e:
                      print(f"Error parsing {filename}: {e}")
              
              def parse_semgrep_results(self, filename):
                  """Enhanced Semgrep parser"""
                  if not os.path.exists(filename):
                      return
                  
                  try:
                      with open(filename, 'r') as f:
                          data = json.load(f)
                      
                      for result in data.get('results', []):
                          vuln_data = self.normalize_semgrep_finding(result)
                          
                          if self.deduplicate_vulnerability(vuln_data):
                              severity = vuln_data['severity'].lower()
                              self.vulnerability_counts[severity] += 1
                              self.all_vulnerabilities.append(vuln_data)
                  
                  except Exception as e:
                      print(f"Error parsing {filename}: {e}")
              
              def normalize_trivy_vulnerability(self, vuln, target):
                  """Normalize Trivy vulnerability format"""
                  return {
                      'id': vuln.get('VulnerabilityID', 'N/A'),
                      'title': vuln.get('Title', 'No title'),
                      'description': self.truncate_text(vuln.get('Description', 'No description')),
                      'severity': vuln.get('Severity', 'UNKNOWN').upper(),
                      'package': vuln.get('PkgName', 'Unknown'),
                      'installed_version': vuln.get('InstalledVersion', 'Unknown'),
                      'fixed_version': vuln.get('FixedVersion', 'Not available'),
                      'target': target,
                      'source': 'Trivy',
                      'type': 'vulnerability',
                      'references': vuln.get('References', [])[:3]
                  }
              
              def normalize_trivy_misconfiguration(self, misc, target):
                  """Normalize Trivy misconfiguration format"""
                  return {
                      'id': misc.get('ID', 'N/A'),
                      'title': misc.get('Title', 'Configuration issue'),
                      'description': self.truncate_text(misc.get('Description', 'Configuration problem detected')),
                      'severity': misc.get('Severity', 'MEDIUM').upper(),
                      'package': 'Configuration',
                      'installed_version': 'N/A',
                      'fixed_version': 'See recommendations',
                      'target': target,
                      'source': 'Trivy',
                      'type': 'misconfiguration',
                      'references': misc.get('References', [])[:2]
                  }
              
              def normalize_trivy_secret(self, secret, target):
                  """Normalize Trivy secret format"""
                  return {
                      'id': secret.get('RuleID', 'SECRET'),
                      'title': f"Secret detected: {secret.get('Title', 'Unknown secret')}",
                      'description': self.truncate_text(secret.get('Match', 'Secret or sensitive data detected')),
                      'severity': secret.get('Severity', 'HIGH').upper(),
                      'package': 'Secrets',
                      'installed_version': 'N/A',
                      'fixed_version': 'Remove or secure',
                      'target': target,
                      'source': 'Trivy',
                      'type': 'secret',
                      'references': []
                  }
              
              def normalize_semgrep_finding(self, finding):
                  """Normalize Semgrep finding format"""
                  # Map Semgrep severity to standard levels
                  severity_map = {
                      'ERROR': 'HIGH',
                      'WARNING': 'MEDIUM', 
                      'INFO': 'LOW'
                  }
                  
                  return {
                      'id': finding.get('check_id', 'SEMGREP'),
                      'title': finding.get('message', 'Static analysis finding'),
                      'description': self.truncate_text(finding.get('extra', {}).get('message', finding.get('message', 'Code quality issue detected'))),
                      'severity': severity_map.get(finding.get('extra', {}).get('severity', 'INFO'), 'MEDIUM'),
                      'package': 'Static Analysis',
                      'installed_version': 'N/A',
                      'fixed_version': 'See fix guidance',
                      'target': finding.get('path', 'Unknown'),
                      'source': 'Semgrep',
                      'type': 'static_analysis',
                      'references': []
                  }
              
              def truncate_text(self, text, max_length=300):
                  """Truncate text to prevent payload bloat"""
                  if not text or len(text) <= max_length:
                      return text
                  return text[:max_length] + "..."
              
              def generate_summary(self):
                  """Generate comprehensive summary"""
                  # Sort vulnerabilities by severity
                  severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
                  self.all_vulnerabilities.sort(key=lambda x: severity_order.get(x['severity'], 4))
                  
                  total = sum(self.vulnerability_counts.values())
                  
                  summary = {
                      'critical': self.vulnerability_counts.get('critical', 0),
                      'high': self.vulnerability_counts.get('high', 0),
                      'medium': self.vulnerability_counts.get('medium', 0),
                      'low': self.vulnerability_counts.get('low', 0),
                      'total': total,
                      'unique_vulnerabilities': len(self.all_vulnerabilities),
                      'vulnerability_types': {
                          'vulnerabilities': len([v for v in self.all_vulnerabilities if v['type'] == 'vulnerability']),
                          'misconfigurations': len([v for v in self.all_vulnerabilities if v['type'] == 'misconfiguration']),
                          'secrets': len([v for v in self.all_vulnerabilities if v['type'] == 'secret']),
                          'static_analysis': len([v for v in self.all_vulnerabilities if v['type'] == 'static_analysis'])
                      }
                  }
                  
                  return summary, self.all_vulnerabilities
          
          # Initialize analyzer
          analyzer = EnhancedSecurityAnalyzer()
          
          # Process all result files
          print("üîç Processing Trivy vulnerability results...")
          analyzer.parse_trivy_results('trivy-vulnerabilities.json')
          
          print("üîç Processing Trivy secret results...")
          analyzer.parse_trivy_results('trivy-secrets.json')
          
          print("üéØ Processing Semgrep results...")
          analyzer.parse_semgrep_results('semgrep-analysis.json')
          
          # Generate final summary
          summary, vulnerabilities = analyzer.generate_summary()
          
          # Output results
          print(f"CRITICAL={summary['critical']}")
          print(f"HIGH={summary['high']}")
          print(f"MEDIUM={summary['medium']}")
          print(f"LOW={summary['low']}")
          print(f"TOTAL={summary['total']}")
          print(f"UNIQUE={summary['unique_vulnerabilities']}")
          
          # Save to environment
          with open(os.environ.get('GITHUB_ENV', '/dev/null'), 'a') as f:
              for key, value in summary.items():
                  if isinstance(value, int):
                      f.write(f"{key.upper()}_COUNT={value}\n")
          
          # Save detailed results
          with open('enhanced-vulnerabilities.json', 'w') as f:
              json.dump(vulnerabilities, f, indent=2)
          
          with open('scan-summary.json', 'w') as f:
              json.dump(summary, f, indent=2)
          
          print(f"üíæ Processed {summary['total']} total findings ({summary['unique_vulnerabilities']} unique)")
          print(f"üìä Breakdown: {summary['vulnerability_types']}")
          EOF
          
          # Run enhanced analyzer
          python3 enhanced_analyzer.py
          
          # Display results
          echo "üìä Enhanced Analysis Results:"
          echo "  üî¥ Critical: ${CRITICAL_COUNT:-0}"
          echo "  üü† High: ${HIGH_COUNT:-0}"
          echo "  üü° Medium: ${MEDIUM_COUNT:-0}"
          echo "  üü¢ Low: ${LOW_COUNT:-0}"
          echo "  üìä Total: ${TOTAL_COUNT:-0}"
          echo "  üéØ Unique: ${UNIQUE_COUNT:-0}"

      # ========================================
      # ENHANCED CALLBACK WITH RETRY LOGIC
      # ========================================
      - name: üì§ Enhanced Result Delivery
        id: deliver-results
        if: always()
        run: |
          echo "üì§ Delivering enhanced results..."
          
          # Calculate metrics
          SCAN_END_TIME=$(date +%s)
          DURATION=$((SCAN_END_TIME - SCAN_START_TIME))
          FINAL_STATUS=$([[ "${{ job.status }}" =~ ^(failure|cancelled)$ ]] && echo "failed" || echo "completed")
          
          # Load vulnerability data
          DETAILED_VULNS="[]"
          if [ -f "scan-results/enhanced-vulnerabilities.json" ]; then
              DETAILED_VULNS=$(cat scan-results/enhanced-vulnerabilities.json | jq -c '.')
          fi
          
          # Create comprehensive callback payload
          jq -n \
              --arg scan_id "${{ env.SCAN_ID }}" \
              --arg status "$FINAL_STATUS" \
              --arg repository "${{ env.REPO_NAME }}" \
              --arg github_url "${{ env.TARGET_REPO }}" \
              --argjson duration "$DURATION" \
              --argjson files_scanned "${{ env.FILES_SCANNED }}" \
              --arg start_time "${{ env.SCAN_TIMESTAMP }}" \
              --arg completed_at "$(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
              --argjson critical "${CRITICAL_COUNT:-0}" \
              --argjson high "${HIGH_COUNT:-0}" \
              --argjson medium "${MEDIUM_COUNT:-0}" \
              --argjson low "${LOW_COUNT:-0}" \
              --argjson total "${TOTAL_COUNT:-0}" \
              --argjson detailed_vulnerabilities "$DETAILED_VULNS" \
              --arg project_types "${{ env.PROJECT_TYPES }}" \
              --arg scan_depth "${{ env.SCAN_DEPTH }}" \
              --argjson cache_hit "${{ steps.cache-security-tools.outputs.cache-hit == 'true' }}" \
              '{
                  scan_id: $scan_id,
                  status: $status,
                  duration: $duration,
                  files_scanned: $files_scanned,
                  start_time: $start_time,
                  completed_at: $completed_at,
                  results: {
                      critical: $critical,
                      high: $high,
                      medium: $medium,
                      low: $low,
                      total: $total,
                      detailed_vulnerabilities: $detailed_vulnerabilities,
                      scan_metadata: {
                          project_types: $project_types,
                          scan_depth: $scan_depth,
                          tools_used: ["trivy", "semgrep"],
                          performance_optimized: $cache_hit,
                          enhanced_analysis: true
                      }
                  }
              }' > enhanced-callback.json
          
          # Enhanced delivery with exponential backoff
          for attempt in 1 2 3 4; do
              echo "üìû Delivery attempt $attempt..."
              
              WAIT_TIME=$((2 ** (attempt - 1)))
              
              HTTP_STATUS=$(curl -s -o response.json -w "%{http_code}" \
                  -X POST \
                  -H "Content-Type: application/json" \
                  -H "User-Agent: Enhanced-Security-Scanner/2.0" \
                  -H "X-Scan-ID: ${{ env.SCAN_ID }}" \
                  --max-time 90 \
                  --retry 0 \
                  -d @enhanced-callback.json \
                  "${{ env.CALLBACK_URL }}")
              
              if [[ "$HTTP_STATUS" =~ ^(200|201|202)$ ]]; then
                  echo "‚úÖ Results delivered successfully!"
                  break
              else
                  echo "‚ö†Ô∏è Delivery attempt $attempt failed (HTTP $HTTP_STATUS)"
                  if [ $attempt -lt 4 ]; then
                      echo "‚è≥ Waiting ${WAIT_TIME}s before retry..."
                      sleep $WAIT_TIME
                  fi
              fi
          done

      - name: üìÅ Archive Enhanced Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: enhanced-scan-results-${{ env.SCAN_ID }}
          path: |
            scan-results/
            enhanced-callback.json
            response.json
          retention-days: 30
          if-no-files-found: warn


# # üõ°Ô∏è DevSecOps Security Scanning Pipeline - Cached Version

# name: üîí Security Scanner

# on:
#   workflow_dispatch:
#     inputs:
#       target_repo:
#         description: 'Repository URL to scan'
#         required: true
#         type: string
#       scan_id:
#         description: 'Unique scan identifier'
#         required: true
#         type: string
#       callback_url:
#         description: 'Callback URL for results'
#         required: true
#         type: string
#       timestamp:
#         description: 'Horodatage du d√©clenchement'
#         required: false
#       scan_depth:
#         description: 'Niveau de scan (quick, standard, deep)'
#         required: false
#         default: 'standard'
#         type: choice
#         options:
#           - standard
#           - comprehensive
#           - quick

# env:
#   SCAN_ID: ${{ github.event.inputs.scan_id }}
#   CALLBACK_URL: ${{ github.event.inputs.callback_url }}
#   TARGET_REPO: ${{ github.event.inputs.target_repo }}
#   SCAN_DEPTH: ${{ github.event.inputs.scan_depth }}
#   SCAN_TIMESTAMP: ${{ github.event.inputs.timestamp }}
#   # Tool versions
#   TRIVY_VERSION: "0.48.3"
#   NODE_VERSION: "18"
#   PYTHON_VERSION: "3.11"

# jobs:
#   security-scan:
#     name: üîç Security Analysis
#     runs-on: ubuntu-latest
#     timeout-minutes: 30
    
#     outputs:
#       scan-status: ${{ steps.final-status.outputs.status }}
#       vulnerabilities-found: ${{ steps.process-results.outputs.total-vulnerabilities }}
#       critical-count: ${{ steps.process-results.outputs.critical }}
#       high-count: ${{ steps.process-results.outputs.high }}
#       medium-count: ${{ steps.process-results.outputs.medium }}
#       low-count: ${{ steps.process-results.outputs.low }}
      
#     steps:
#       - name: üìã Job Information
#         run: |
#           echo "üöÄ Starting Security Scan"
#           echo "üì¶ Repository: ${{ env.TARGET_REPO }}"
#           echo "üÜî Scan ID: ${{ env.SCAN_ID }}"
#           echo "üìû Callback: ${{ env.CALLBACK_URL }}"
#           echo "üîç Depth: ${{ env.SCAN_DEPTH }}"
#           echo "‚è∞ Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

#       - name: ‚ö° Setup Environment
#         run: |
#           echo "SCAN_START_TIME=$(date +%s)" >> $GITHUB_ENV
#           echo "SCAN_TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          
#           # Create results directory
#           mkdir -p scan-results
          
#           # Initialize counters
#           echo "FILES_SCANNED=0" >> $GITHUB_ENV
#           echo "TOTAL_VULNERABILITIES=0" >> $GITHUB_ENV
#           echo "CRITICAL_COUNT=0" >> $GITHUB_ENV
#           echo "HIGH_COUNT=0" >> $GITHUB_ENV
#           echo "MEDIUM_COUNT=0" >> $GITHUB_ENV
#           echo "LOW_COUNT=0" >> $GITHUB_ENV

#       # ===============================
#       # BASIC SETUP
#       # ===============================
#       - name: üêç Setup Python
#         uses: actions/setup-python@v4
#         with:
#           python-version: ${{ env.PYTHON_VERSION }}

#       - name: üü¢ Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: ${{ env.NODE_VERSION }}

#       # ===============================
#       # ROBUST TOOL INSTALLATION WITH FALLBACK
#       # ===============================
#       - name: üìÖ Get Date for Cache Key
#         id: get-date
#         run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

#       - name: üì¶ Cache Security Tools
#         id: cache-tools
#         uses: actions/cache@v3
#         with:
#           path: |
#             ~/.local/bin/trivy
#             ~/.local/bin/snyk
#             ~/.cache/trivy
#             ~/.local/lib/node_modules/snyk
#           key: security-tools-v2-${{ env.TRIVY_VERSION }}-node${{ env.NODE_VERSION }}-${{ steps.get-date.outputs.date }}
#           restore-keys: |
#             security-tools-v2-${{ env.TRIVY_VERSION }}-node${{ env.NODE_VERSION }}-
#             security-tools-v2-${{ env.TRIVY_VERSION }}-

#       - name: üîß Install/Verify Security Tools
#         id: install-tools
#         run: |
#           echo "üîß Installing/Verifying security tools..."
          
#           # Create local bin directory
#           mkdir -p ~/.local/bin
#           echo "$HOME/.local/bin" >> $GITHUB_PATH
          
#           # Initialize flags
#           TRIVY_OK=false
#           SNYK_OK=false
          
#           # Check/Install Trivy
#           echo "üìã Checking Trivy..."
#           if [ -f ~/.local/bin/trivy ] && ~/.local/bin/trivy --version >/dev/null 2>&1; then
#             echo "‚úÖ Trivy found in cache"
#             TRIVY_OK=true
#           else
#             echo "üì¶ Installing Trivy v${{ env.TRIVY_VERSION }}..."
#             wget -qO- "https://github.com/aquasecurity/trivy/releases/download/v${{ env.TRIVY_VERSION }}/trivy_${{ env.TRIVY_VERSION }}_Linux-64bit.tar.gz" | tar -xzf - -C ~/.local/bin
#             chmod +x ~/.local/bin/trivy
#             if ~/.local/bin/trivy --version >/dev/null 2>&1; then
#               TRIVY_OK=true
#               echo "‚úÖ Trivy installed successfully"
#             else
#               echo "‚ùå Trivy installation failed"
#             fi
#           fi
          
#           # Check/Install Snyk
#           echo "üìã Checking Snyk..."
#           if [ -f ~/.local/bin/snyk ] && ~/.local/bin/snyk --version >/dev/null 2>&1; then
#             echo "‚úÖ Snyk found in cache"
#             SNYK_OK=true
#           else
#             echo "üì¶ Installing Snyk..."
            
#             # Method 1: Try to restore from node_modules cache
#             if [ -f ~/.local/lib/node_modules/snyk/bin/snyk ]; then
#               echo "üîó Creating symlink from cached node_modules..."
#               ln -sf ~/.local/lib/node_modules/snyk/bin/snyk ~/.local/bin/snyk
#               chmod +x ~/.local/bin/snyk
#             fi
            
#             # Test if it works
#             if [ -f ~/.local/bin/snyk ] && ~/.local/bin/snyk --version >/dev/null 2>&1; then
#               SNYK_OK=true
#               echo "‚úÖ Snyk restored from cache"
#             else
#               # Method 2: Fresh installation
#               echo "üì¶ Installing Snyk fresh..."
#               mkdir -p ~/.local/lib/node_modules
#               npm install --prefix ~/.local snyk@latest >/dev/null 2>&1
              
#               # Create direct symlink
#               if [ -f ~/.local/lib/node_modules/snyk/bin/snyk ]; then
#                 ln -sf ~/.local/lib/node_modules/snyk/bin/snyk ~/.local/bin/snyk
#                 chmod +x ~/.local/bin/snyk
#               fi
              
#               # Test again
#               if [ -f ~/.local/bin/snyk ] && ~/.local/bin/snyk --version >/dev/null 2>&1; then
#                 SNYK_OK=true
#                 echo "‚úÖ Snyk installed fresh"
#               else
#                 # Method 3: Global fallback
#                 echo "üì¶ Trying global Snyk installation..."
#                 npm install -g snyk@latest >/dev/null 2>&1
                
#                 # Create symlink to global installation
#                 if which snyk >/dev/null 2>&1; then
#                   ln -sf $(which snyk) ~/.local/bin/snyk
#                   SNYK_OK=true
#                   echo "‚úÖ Snyk installed globally and linked"
#                 else
#                   echo "‚ö†Ô∏è Snyk installation failed, will continue without Snyk"
#                 fi
#               fi
#             fi
#           fi
          
#           # Update Trivy database
#           if [ "$TRIVY_OK" = true ]; then
#             echo "üîÑ Updating Trivy vulnerability database..."
#             ~/.local/bin/trivy image --download-db-only >/dev/null 2>&1 || echo "‚ö†Ô∏è Trivy DB update failed, will use cached DB"
#           fi
          
#           # Set outputs
#           echo "trivy-ok=$TRIVY_OK" >> $GITHUB_OUTPUT
#           echo "snyk-ok=$SNYK_OK" >> $GITHUB_OUTPUT
#           echo "cache-hit=${{ steps.cache-tools.outputs.cache-hit }}" >> $GITHUB_OUTPUT
          
#           echo "üìä Tool Status:"
#           echo "  Trivy: $TRIVY_OK"
#           echo "  Snyk: $SNYK_OK"
#           echo "  Cache Hit: ${{ steps.cache-tools.outputs.cache-hit }}"

#       # ===============================
#       # VERIFY TOOLS
#       # ===============================
#       - name: ‚úÖ Verify Tool Installations
#         run: |
#           echo "üîç Final tool verification..."
#           echo "‚ö° Cache Performance:"
#           echo "  üîß Tools cache hit: ${{ steps.install-tools.outputs.cache-hit }}"
#           echo "  üîß Trivy OK: ${{ steps.install-tools.outputs.trivy-ok }}"
#           echo "  üîß Snyk OK: ${{ steps.install-tools.outputs.snyk-ok }}"
          
#           echo ""
#           echo "üìã Tool Versions:"
          
#           # Verify Trivy
#           if [ "${{ steps.install-tools.outputs.trivy-ok }}" = "true" ]; then
#             echo "Trivy: $(~/.local/bin/trivy --version | head -1)"
#           else
#             echo "‚ùå Trivy not available - filesystem/config/secret scans will be skipped"
#           fi
          
#           # Verify Snyk
#           if [ "${{ steps.install-tools.outputs.snyk-ok }}" = "true" ]; then
#             echo "Snyk: $(~/.local/bin/snyk --version)"
#           else
#             echo "‚ö†Ô∏è Snyk not available - dependency scans will be skipped"
#           fi
          
#           echo "Node.js: $(node --version)"
#           echo "Python: $(python3 --version)"
          
#           # Check if at least one security tool is available
#           if [ "${{ steps.install-tools.outputs.trivy-ok }}" = "false" ]; then
#             echo "‚ùå No security scanning tools available!"
#             exit 1
#           fi
          
#           echo "‚úÖ Tool verification completed"

#       # ===============================
#       # REPOSITORY CLONING
#       # ===============================
#       - name: üìÇ Clone Target Repository
#         id: clone-repo
#         run: |
#           echo "üîÑ Cloning repository..."
          
#           # Extract repo info from URL
#           REPO_URL="${{ env.TARGET_REPO }}"
#           REPO_NAME=$(echo $REPO_URL | sed 's/.*github\.com\///g' | sed 's/\.git$//g')
#           REPO_DIR=$(echo $REPO_NAME | sed 's/.*\///g')
          
#           echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
#           echo "REPO_DIR=$REPO_DIR" >> $GITHUB_ENV
          
#           # Clone with depth based on scan level
#           CLONE_DEPTH=1
#           if [ "${{ env.SCAN_DEPTH }}" = "comprehensive" ]; then
#             CLONE_DEPTH=50
#           elif [ "${{ env.SCAN_DEPTH }}" = "standard" ]; then
#             CLONE_DEPTH=10
#           fi
          
#           echo "üì• Cloning with depth: $CLONE_DEPTH"
#           git clone --depth=$CLONE_DEPTH "$REPO_URL" "$REPO_DIR"
          
#           if [ ! -d "$REPO_DIR" ]; then
#             echo "‚ùå Failed to clone repository"
#             exit 1
#           fi
          
#           cd "$REPO_DIR"
          
#           # Count files (excluding .git directory)
#           FILE_COUNT=$(find . -type f -not -path './.git/*' | wc -l)
#           echo "FILES_SCANNED=$FILE_COUNT" >> $GITHUB_ENV
          
#           echo "‚úÖ Repository cloned: $FILE_COUNT files"
#           echo "repository=$REPO_NAME" >> $GITHUB_OUTPUT
#           echo "directory=$REPO_DIR" >> $GITHUB_OUTPUT
#           echo "files-count=$FILE_COUNT" >> $GITHUB_OUTPUT

#       # ===============================
#       # SNYK CONFIGURATION
#       # ===============================
#       - name: üîê Configure Snyk Authentication
#         if: steps.install-tools.outputs.snyk-ok == 'true' && (env.SCAN_DEPTH == 'comprehensive' || env.SCAN_DEPTH == 'standard')
#         env:
#           SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
#         run: |
#           if [ -n "$SNYK_TOKEN" ]; then
#             ~/.local/bin/snyk auth "$SNYK_TOKEN"
#             echo "‚úÖ Snyk authenticated"
#           else
#             echo "‚ö†Ô∏è SNYK_TOKEN not provided - some scans will be limited"
#           fi

#       # ===============================
#       # SECURITY SCANS (with conditional execution)
#       # ===============================
#       - name: üîç Filesystem Security Scan
#         id: trivy-fs
#         if: steps.install-tools.outputs.trivy-ok == 'true'
#         continue-on-error: true
#         run: |
#           echo "üîç Running Trivy filesystem scan..."
#           cd "${{ env.REPO_DIR }}"
          
#           # Ensure output directory exists
#           mkdir -p ../scan-results
          
#           # Trivy filesystem scan with JSON output
#           ~/.local/bin/trivy fs . \
#             --format json \
#             --output ../scan-results/trivy-filesystem.json \
#             --severity CRITICAL,HIGH,MEDIUM,LOW \
#             --timeout 10m \
#             --quiet \
#             --exit-code 0 || {
#               echo "‚ö†Ô∏è Trivy filesystem scan had issues, but continuing..."
#               echo '{"Results": []}' > ../scan-results/trivy-filesystem.json
#             }
          
#           echo "‚úÖ Filesystem scan completed"

#       - name: üîê Secret Detection
#         id: trivy-secrets
#         if: steps.install-tools.outputs.trivy-ok == 'true'
#         continue-on-error: true
#         run: |
#           echo "üîê Scanning for secrets..."
#           cd "${{ env.REPO_DIR }}"
          
#           ~/.local/bin/trivy fs . \
#             --scanners secret \
#             --format json \
#             --output ../scan-results/trivy-secrets.json \
#             --timeout 5m \
#             --quiet \
#             --exit-code 0 || {
#               echo "‚ö†Ô∏è Secret scan had issues, but continuing..."
#               echo '{"Results": []}' > ../scan-results/trivy-secrets.json
#             }
          
#           echo "‚úÖ Secret detection completed"

#       - name: ‚öôÔ∏è Configuration Security Scan
#         id: trivy-config
#         if: steps.install-tools.outputs.trivy-ok == 'true'
#         continue-on-error: true
#         run: |
#           echo "‚öôÔ∏è Scanning configuration files..."
#           cd "${{ env.REPO_DIR }}"
          
#           ~/.local/bin/trivy fs . \
#             --scanners config \
#             --format json \
#             --output ../scan-results/trivy-config.json \
#             --timeout 5m \
#             --quiet \
#             --exit-code 0 || {
#               echo "‚ö†Ô∏è Config scan had issues, but continuing..."
#               echo '{"Results": []}' > ../scan-results/trivy-config.json
#             }
          
#           echo "‚úÖ Configuration scan completed"

#       - name: üì¶ Dependency Security Scan
#         id: snyk-dependencies
#         if: steps.install-tools.outputs.snyk-ok == 'true' && env.SKIP_SNYK != 'true'
#         continue-on-error: true
#         run: |
#           echo "üì¶ Scanning dependencies with Snyk..."
#           cd "${{ env.REPO_DIR }}"
          
#           # Create empty results file in case Snyk fails
#           echo '{"vulnerabilities": []}' > ../scan-results/snyk-dependencies.json
          
#           # Snyk test with JSON output
#           ~/.local/bin/snyk test \
#             --json \
#             --all-projects \
#             --detection-depth=3 \
#             --severity-threshold=low > ../scan-results/snyk-dependencies.json 2>/dev/null || {
#               echo "‚ö†Ô∏è Snyk scan completed with findings or errors"
#               # If Snyk fails, ensure we have a valid JSON structure
#               if [ ! -s ../scan-results/snyk-dependencies.json ]; then
#                 echo '{"vulnerabilities": []}' > ../scan-results/snyk-dependencies.json
#               fi
#             }
          
#           echo "‚úÖ Dependency scan completed"

#       # ===============================
#       # CREATE EMPTY RESULTS FOR SKIPPED SCANS
#       # ===============================
#       - name: üìù Create Empty Results for Skipped Scans
#         run: |
#           cd scan-results
          
#           # Create empty results for any missing scan files
#           for file in trivy-filesystem.json trivy-secrets.json trivy-config.json snyk-dependencies.json; do
#             if [ ! -f "$file" ]; then
#               if [[ "$file" == snyk-* ]]; then
#                 echo '{"vulnerabilities": []}' > "$file"
#               else
#                 echo '{"Results": []}' > "$file"
#               fi
#               echo "üìù Created empty result file: $file"
#             fi
#           done

#       - name: üìä Process and Aggregate Results
#         id: process-results
#         run: |
#           echo "üìä Processing scan results..."
#           cd scan-results
          
#           # Initialize counters
#           CRITICAL=0
#           HIGH=0
#           MEDIUM=0
#           LOW=0
#           TOTAL=0
          
#           # Create Python script for parsing results with detailed vulnerabilities
#           cat > parse_results.py << 'EOF'
#           import json
#           import sys
#           import os
          
#           def parse_trivy_results(filename, scan_type="filesystem"):
#               """Parse Trivy results and extract detailed vulnerability information"""
#               counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
#               vulnerabilities = []
              
#               try:
#                   if not os.path.exists(filename) or os.path.getsize(filename) == 0:
#                       print(f"File {filename} is empty or does not exist")
#                       return counts, vulnerabilities
                      
#                   with open(filename, 'r') as f:
#                       data = json.load(f)
                  
#                   if isinstance(data, dict) and 'Results' in data:
#                       for result in data['Results']:
#                           target = result.get('Target', 'Unknown')
                          
#                           if 'Vulnerabilities' in result and result['Vulnerabilities']:
#                               for vuln in result['Vulnerabilities']:
#                                   severity = vuln.get('Severity', '').lower()
#                                   if severity in counts:
#                                       counts[severity] += 1
                                      
#                                       # Extract detailed vulnerability info
#                                       vulnerability_detail = {
#                                           'id': vuln.get('VulnerabilityID', 'N/A'),
#                                           'title': vuln.get('Title', 'No title'),
#                                           'description': (vuln.get('Description', 'No description')[:200] + '...') if len(vuln.get('Description', '')) > 200 else vuln.get('Description', 'No description'),
#                                           'severity': severity.upper(),
#                                           'package': vuln.get('PkgName', 'Unknown'),
#                                           'installed_version': vuln.get('InstalledVersion', 'Unknown'),
#                                           'fixed_version': vuln.get('FixedVersion', 'Not available'),
#                                           'target': target,
#                                           'source': 'Trivy',
#                                           'scan_type': scan_type,
#                                           'references': vuln.get('References', [])[:3]  # Limite √† 3 r√©f√©rences
#                                       }
                                      
#                                       vulnerabilities.append(vulnerability_detail)
                  
#                   print(f"Parsed {filename}: {counts} - {len(vulnerabilities)} detailed vulnerabilities")
                  
#               except Exception as e:
#                   print(f"Error parsing {filename}: {e}")
              
#               return counts, vulnerabilities
          
#           def parse_snyk_results(filename):
#               """Parse Snyk results and extract detailed vulnerability information"""
#               counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
#               vulnerabilities = []
              
#               try:
#                   if not os.path.exists(filename) or os.path.getsize(filename) == 0:
#                       print(f"File {filename} is empty or does not exist")
#                       return counts, vulnerabilities
                      
#                   with open(filename, 'r') as f:
#                       data = json.load(f)
                  
#                   if isinstance(data, dict):
#                       if 'vulnerabilities' in data:
#                           for vuln in data['vulnerabilities']:
#                               severity = vuln.get('severity', '').lower()
#                               if severity in counts:
#                                   counts[severity] += 1
                                  
#                                   # Extract detailed vulnerability info
#                                   vulnerability_detail = {
#                                       'id': vuln.get('id', 'N/A'),
#                                       'title': vuln.get('title', 'No title'),
#                                       'description': (vuln.get('description', 'No description')[:200] + '...') if len(vuln.get('description', '')) > 200 else vuln.get('description', 'No description'),
#                                       'severity': severity.upper(),
#                                       'package': vuln.get('packageName', 'Unknown'),
#                                       'installed_version': vuln.get('version', 'Unknown'),
#                                       'fixed_version': ', '.join(vuln.get('fixedIn', [])) if vuln.get('fixedIn') else 'Not available',
#                                       'target': vuln.get('from', ['Unknown'])[0] if vuln.get('from') else 'Unknown',
#                                       'source': 'Snyk',
#                                       'scan_type': 'dependency',
#                                       'references': [vuln.get('url')] if vuln.get('url') else []
#                                   }
                                  
#                                   vulnerabilities.append(vulnerability_detail)
                                  
#                       elif 'error' in data:
#                           print(f"Snyk error: {data['error']}")
                  
#                   print(f"Parsed {filename}: {counts} - {len(vulnerabilities)} detailed vulnerabilities")
                  
#               except Exception as e:
#                   print(f"Error parsing {filename}: {e}")
              
#               return counts, vulnerabilities
          
#           # Parse all result files
#           total_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
#           all_vulnerabilities = []
          
#           # Parse Trivy results
#           trivy_files = [
#               ('trivy-filesystem.json', 'filesystem'),
#               ('trivy-secrets.json', 'secrets'), 
#               ('trivy-config.json', 'configuration')
#           ]
          
#           for filename, scan_type in trivy_files:
#               counts, vulns = parse_trivy_results(filename, scan_type)
#               for severity in total_counts:
#                   total_counts[severity] += counts[severity]
#               all_vulnerabilities.extend(vulns)
          
#           # Parse Snyk results
#           snyk_counts, snyk_vulns = parse_snyk_results('snyk-dependencies.json')
#           for severity in total_counts:
#               total_counts[severity] += snyk_counts[severity]
#           all_vulnerabilities.extend(snyk_vulns)
          
#           # Sort vulnerabilities by severity (critical first)
#           severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
#           all_vulnerabilities.sort(key=lambda x: severity_order.get(x['severity'], 4))
          
#           # Output results
#           total = sum(total_counts.values())
#           print(f"CRITICAL={total_counts['critical']}")
#           print(f"HIGH={total_counts['high']}")
#           print(f"MEDIUM={total_counts['medium']}")
#           print(f"LOW={total_counts['low']}")
#           print(f"TOTAL={total}")
#           print(f"DETAILED_VULNERABILITIES={len(all_vulnerabilities)}")
          
#           # Save to environment file
#           with open(os.environ.get('GITHUB_ENV', '/dev/null'), 'a') as f:
#               f.write(f"CRITICAL_COUNT={total_counts['critical']}\n")
#               f.write(f"HIGH_COUNT={total_counts['high']}\n")
#               f.write(f"MEDIUM_COUNT={total_counts['medium']}\n")
#               f.write(f"LOW_COUNT={total_counts['low']}\n")
#               f.write(f"TOTAL_VULNERABILITIES={total}\n")
          
#           # Save detailed vulnerabilities to JSON file
#           with open('detailed-vulnerabilities.json', 'w') as f:
#               json.dump(all_vulnerabilities, f, indent=2)
          
#           print(f"üíæ Saved {len(all_vulnerabilities)} detailed vulnerabilities to detailed-vulnerabilities.json")
#           EOF
          
#           # Run Python script
#           python3 parse_results.py
          
#           # Get the results from environment variables
#           CRITICAL=${CRITICAL_COUNT:-0}
#           HIGH=${HIGH_COUNT:-0}
#           MEDIUM=${MEDIUM_COUNT:-0}
#           LOW=${LOW_COUNT:-0}
#           TOTAL=${TOTAL_VULNERABILITIES:-0}
          
#           # Set outputs
#           echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
#           echo "high=$HIGH" >> $GITHUB_OUTPUT
#           echo "medium=$MEDIUM" >> $GITHUB_OUTPUT
#           echo "low=$LOW" >> $GITHUB_OUTPUT
#           echo "total-vulnerabilities=$TOTAL" >> $GITHUB_OUTPUT
          
#           # Create summary JSON
#           cat > scan-summary.json << EOF
#           {
#             "scan_id": "${{ env.SCAN_ID }}",
#             "repository": "${{ env.REPO_NAME }}",
#             "scan_timestamp": "${{ env.SCAN_TIMESTAMP }}",
#             "files_scanned": ${{ env.FILES_SCANNED }},
#             "vulnerabilities": {
#               "critical": $CRITICAL,
#               "high": $HIGH,
#               "medium": $MEDIUM,
#               "low": $LOW,
#               "total": $TOTAL
#             },
#             "scan_depth": "${{ env.SCAN_DEPTH }}",
#             "tools_used": ["trivy", "snyk"],
#             "cache_performance": {
#               "trivy_cache_hit": "${{ steps.cache-trivy.outputs.cache-hit }}",
#               "node_cache_hit": "${{ steps.cache-node-global.outputs.cache-hit }}",
#               "scan_duration_optimized": true
#             }
#           }
#           EOF
          
#           echo "üìä Results Summary:"
#           echo "  üî¥ Critical: $CRITICAL"
#           echo "  üü† High: $HIGH"  
#           echo "  üü° Medium: $MEDIUM"
#           echo "  üü¢ Low: $LOW"
#           echo "  üìä Total: $TOTAL vulnerabilities"
#           echo "  üìÅ Files scanned: ${{ env.FILES_SCANNED }}"
          
#           # Show cache performance
#           echo "‚ö° Cache Performance:"
#           echo "  üîß Trivy cached: ${{ steps.cache-trivy.outputs.cache-hit }}"
#           echo "  üü¢ Node.js cached: ${{ steps.cache-node-global.outputs.cache-hit }}"
          
#           # Show count of detailed vulnerabilities found
#           if [ -f "detailed-vulnerabilities.json" ]; then
#             DETAILED_COUNT=$(python3 -c "import json; print(len(json.load(open('detailed-vulnerabilities.json'))))" 2>/dev/null || echo "0")
#             echo "  üìã Detailed vulnerabilities: $DETAILED_COUNT"
#           fi

#       - name: üì§ Send Results to Backend
#         id: send-results
#         if: always()
#         run: |
#           echo "üì§ Sending results to callback URL..."
              
#           # Calculate scan duration
#           SCAN_END_TIME=$(date +%s)
#           DURATION=$((SCAN_END_TIME - SCAN_START_TIME))
           
#           # Determine final status
#           FINAL_STATUS="completed"
#           if [ "${{ job.status }}" = "failure" ] || [ "${{ job.status }}" = "cancelled" ]; then
#             FINAL_STATUS="failed"
#           fi
              
#           # Get vulnerability counts (with defaults)
#           CRITICAL_COUNT=${CRITICAL_COUNT:-0}
#           HIGH_COUNT=${HIGH_COUNT:-0}
#           MEDIUM_COUNT=${MEDIUM_COUNT:-0}
#           LOW_COUNT=${LOW_COUNT:-0}
#           TOTAL_VULNERABILITIES=${TOTAL_VULNERABILITIES:-0}
             
#           # Read detailed vulnerabilities if file exists
#           DETAILED_VULNS="[]"
#           if [ -f "scan-results/detailed-vulnerabilities.json" ]; then
#             DETAILED_VULNS=$(cat scan-results/detailed-vulnerabilities.json | jq -c '.')
#             echo "üìã Found $(echo "$DETAILED_VULNS" | jq length) detailed vulnerabilities"
#           elif [ -f "detailed-vulnerabilities.json" ]; then
#             DETAILED_VULNS=$(cat detailed-vulnerabilities.json | jq -c '.')
#             echo "üìã Found $(echo "$DETAILED_VULNS" | jq length) detailed vulnerabilities"
#           fi
              
#           # Create callback payload with detailed vulnerabilities and cache info
#           jq -n \
#             --arg scan_id "${{ env.SCAN_ID }}" \
#             --arg status "$FINAL_STATUS" \
#             --arg repository "${{ env.REPO_NAME }}" \
#             --arg github_url "${{ env.TARGET_REPO }}" \
#             --argjson duration "$DURATION" \
#             --argjson files_scanned "${{ env.FILES_SCANNED }}" \
#             --arg start_time "${{ env.SCAN_TIMESTAMP }}" \
#             --arg completed_at "$(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
#             --argjson critical "$CRITICAL_COUNT" \
#             --argjson high "$HIGH_COUNT" \
#             --argjson medium "$MEDIUM_COUNT" \
#             --argjson low "$LOW_COUNT" \
#             --argjson total "$TOTAL_VULNERABILITIES" \
#             --arg scan_timestamp "${{ env.SCAN_TIMESTAMP }}" \
#             --arg scan_depth "${{ env.SCAN_DEPTH }}" \
#             --argjson detailed_vulnerabilities "$DETAILED_VULNS" \
#             --arg trivy_cached "${{ steps.cache-trivy.outputs.cache-hit }}" \
#             --arg node_cached "${{ steps.cache-node-global.outputs.cache-hit }}" \
#             '{
#               scan_id: $scan_id,
#               status: $status,
#               repository: $repository,
#               github_url: $github_url,
#               duration: $duration,
#               files_scanned: $files_scanned,
#               start_time: $start_time,
#               completed_at: $completed_at,
#               results: {
#                 critical: $critical,
#                 high: $high,
#                 medium: $medium,
#                 low: $low,
#                 total: $total,
#                 scan_timestamp: $scan_timestamp,
#                 scan_depth: $scan_depth,
#                 tools_used: ["trivy", "snyk"],
#                 detailed_vulnerabilities: $detailed_vulnerabilities,
#                 cache_performance: {
#                   trivy_cache_hit: ($trivy_cached == "true"),
#                   node_cache_hit: ($node_cached == "true"),
#                   performance_optimized: true
#                 }
#               }
#             }' > callback-payload.json
              
#           echo "üìã Callback payload created with $(echo "$DETAILED_VULNS" | jq -r 'length') detailed vulnerabilities"
#           echo "‚ö° Cache hits - Trivy: ${{ steps.cache-trivy.outputs.cache-hit }}, Node: ${{ steps.cache-node-global.outputs.cache-hit }}"
              
#           # Show summary of payload (without showing full detailed vulnerabilities to avoid log spam)
#           echo "üìã Payload summary:"
#           cat callback-payload.json | jq 'del(.results.detailed_vulnerabilities) + {detailed_vulnerabilities_count: (.results.detailed_vulnerabilities | length)}'
              
#           # Validate JSON before sending
#           if ! jq empty callback-payload.json 2>/dev/null; then
#             echo "‚ùå Generated JSON is invalid!"
#             cat callback-payload.json | head -20
#             exit 1
#           fi
              
#           # Send to callback URL with retries
#           CALLBACK_SUCCESS=false
#           for attempt in 1 2 3; do
#             echo "üìû Attempt $attempt: Sending to ${{ env.CALLBACK_URL }}"
            
#             HTTP_STATUS=$(curl -s -o callback-response.json -w "%{http_code}" \
#               -X POST \
#               -H "Content-Type: application/json" \
#               -H "User-Agent: GitHub-Actions-Security-Scanner/1.0" \
#               -H "Accept: application/json" \
#               --max-time 60 \
#               --retry 0 \
#               -d @callback-payload.json \
#               "${{ env.CALLBACK_URL }}")
            
#             echo "Response status: $HTTP_STATUS"
            
#             if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ] || [ "$HTTP_STATUS" = "202" ]; then
#               echo "‚úÖ Callback successful!"
#               CALLBACK_SUCCESS=true
#               if [ -f callback-response.json ]; then
#                 echo "Response body:"
#                 cat callback-response.json
#               fi
#               break
#             else
#               echo "‚ö†Ô∏è Callback failed with status $HTTP_STATUS"
#               if [ -f callback-response.json ]; then
#                 echo "Response body:"
#                 cat callback-response.json
#               fi
              
#               if [ $attempt -lt 3 ]; then
#                 echo "Retrying in 10 seconds..."
#                 sleep 10
#               fi
#             fi
#           done
              
#           if [ "$CALLBACK_SUCCESS" = "false" ]; then
#             echo "‚ùå All callback attempts failed"
#             echo "callback-status=failed" >> $GITHUB_OUTPUT
#           else
#             echo "callback-status=success" >> $GITHUB_OUTPUT
#           fi
              
#           # Set outputs
#           echo "duration=$DURATION" >> $GITHUB_OUTPUT
#           echo "final-status=$FINAL_STATUS" >> $GITHUB_OUTPUT
      
          
#       - name: üìã Final Status
#         id: final-status
#         if: always()
#         run: |
#           echo "‚úÖ Scan completed"
#           echo "status=success" >> $GITHUB_OUTPUT

#       - name: üìÅ Upload Scan Results
#         if: always()
#         uses: actions/upload-artifact@v4
#         with:
#           name: security-scan-results-${{ env.SCAN_ID }}
#           path: |
#             scan-results/
#             callback-payload.json
#             callback-response.json
#           retention-days: 30
#           if-no-files-found: warn
